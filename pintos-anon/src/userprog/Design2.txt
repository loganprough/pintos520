		           +--------------------------+
				   |         CIS 520          |
		           | PROJECT 2: USER PROGRAMS |
		           |     DESIGN DOCUMENT      |
		           +--------------------------+

---- GROUP ----

>> Fill in the names of your group members.

Logan Prough
Mark McGuire


---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

On Logan's laptop, only 13 out of 80 tests fail, but when Mark runs the same code
on his end, 16 out of 80 tests fail. We were both running the same code present
in the Master branch of our Git repository, so we have no clue why more tests pass
on Logan's laptop.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

Two solutions on Github, cited in source code where relevant:
https://github.com/ryantimwilson/Pintos-Project-2
https://github.com/pindexis/pintos-project2


			   ARGUMENT PASSING
			   ================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

We didn't use any additional structs, glabal variables, static variables,
typedefs, or enumerations for argument passing. We mainly used character
arrays to copy strings and the strtok_r() function.

---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?

We use the strtok_r() function because it automatically gets "tokens" (each
argument) and handles multiple spaces for us. 

First we make a copy of the command line string and run through a loop to count the
number of arguments.

Next we use a different copy of the command line to push the content of each argument
to the stack and save the start address in an array of char pointers.

After that, we push the pointers from the aforementioned array onto the stack in the
same order as the arguments were on the command line, followed by argc.

To avoid overflowing the stack page, in process_execute() the strlcpy() function limits
the length of the command line to the page size.


---- RATIONALE ----

>> A3: Why does Pintos implement strtok_r() but not strtok()?

The _r variant is reentrant, which means it is safe to call
from multiple threads simultaneously. Strtok() is not safe
to call from multiple threads simultaneously, so the Pintos
creators probably only implemented strtok_r() to help students
avoid bugs from multiple threads using it.

>> A4: In Pintos, the kernel separates commands into an executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.

Advantage 1: Shell substitution. The shell can choose to let users do fancy things
             such as set environment variables and use their value in command line
             arguments or use the output of a command as a command line argument.

Advantage 2: Separating arguments requires nothing special, so it's safer to do it
             in user space where a problem is less likely to break the entire system.


			     SYSTEM CALLS
			     ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.


struct thread
  ...
  struct list list_fds; // list for file descriptors
  struct list list_children; // list of struct_child to keep track of children
  struct struct_child *child; // Pointer to struct_child in parent so status can be set in thread_exit()
  ...

// Struct to go in list of open files
struct fd_struct {
  int fd; // file descriptor
  struct file *file; // struct file of open file
  struct list_elem felem; // list element for list_fds
};

// Struct to go in list of children
struct child_struct {
  int id; // Child pid
  struct semaphore exited; // Semaphore to wait on to know when it exited
  bool waited; // Boolean to track if wait() had already waited on this child
  int status; // Exit status; set in thread_exit()
  struct list_elem celem; // List element for list of children
};


>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?

A file descriptor is part of a struct that belongs to a single process.
It lets a process identify a file it has open with an integer rather
than the file's full path. The other members in the struct that stores
the file descriptor have the information about the file it belongs to.

File descriptors are only unique within a single process.


---- ALGORITHMS ----

>> B3: Describe your code for reading and writing user data from the
>> kernel.

The kernel code calls a function we wrote called user_kernel_conversion()
to convert memory addresses from user addresses to kernel addresses every
time the system calls need to read or write user data.

>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel.  What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result?  What about
>> for a system call that only copies 2 bytes of data?  Is there room
>> for improvement in these numbers, and how much?

Least: one time, if all data is copied at once
Greatest: 4,096 times, if data is written one byte at a time.

For a system call that copies two bytes:

Least: one time
Greatest: two times

There is room for improvement. If the kernel kept a cache of physical
memory address mappings it could reduce the number of calls to 
pagedir_get_page() greatly. It would always need to call it at
least once though.

>> B5: Briefly describe your implementation of the "wait" system call
>> and how it interacts with process termination.

Each process has a child_struct pointer that points to the child_struct
in its parent. When a child exits, it sets its exit status in this struct
and ups a semaphore called 'exited'. wait() tries to down 'exited', so it
can't continue until the child exits and ups it after the status is set.

>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value.  Such accesses must cause the
>> process to be terminated.  System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point.  This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling?  Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed?  In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues.  Give an example.

We made two functions to validate pointers, one for strings and another
for any other pointer. The one for strings takes a pointer to a character
pointer, then validates both the pointer and the address stored at the
pointer's address. Next it calculates strlen() of the string and 
checks that the memory address at the end of the string is also valid.
The other function just checks that the pointer it's given is valid and
returns the kernel address so the system call can use the data.

This worked well because we made the system calls work normally, then
wrapped all of the user-supplied pointers in the two functions to make
sure they were valid and the bad pointer tests passed. 

We didn't make sure resources get freed when a process is killed...
That would be a major weakness of our design.

As an example, say a user program calls write() and passes a bad
pointer to the buffer with data to write. The syscall handler
calls verify_string() with the pointer. verify_string() checks
that the pointer is valid and goes to a mapped segment by calling
user_kernel_conversion(), then finally checks that the end of the
string is also at a valid user address. If these tests pass, it
returns and the system call continues on.


---- SYNCHRONIZATION ----

>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading.  How does your code ensure this?  How is the load
>> success/failure status passed back to the thread that calls "exec"?

We added an additional check in process_execute() to make sure the file
can be opened before loading it. If thread_create() fails, it returns
TID_ERROR to process_execute().

>> B8: Consider parent process P with child process C.  How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits?  After C exits?  How do you ensure
>> that all resources are freed in each case?  How about when P
>> terminates without waiting, before C exits?  After C exits?  Are
>> there any special cases?

We used a semaphore! The semaphore, called exited, is a member of
child_struct. 'exited' is initialized to zero in thread_create() 
before C runs. 'exited' is only greater than zero when thread_exit()
ups it. When P waits for C, it must down 'exited'. If P waits after
C exited, the exit status is waiting in the child_struct for C in P's
list of children. 'exited' will have a value of 1, so wait() can down
it and read the exit status without a problem. If P waits before C
exits, it still must down 'exited' so the semaphore blocks it until
C exits. 

---- RATIONALE ----

>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?

It let us validate pointers passed in system calls most easily.

>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?

Advantages: It seems fairly simple and easy to understand
Disadantages: There's probably a more efficient way to do it than
              a doubly linked list of structs

>> B11: The default tid_t to pid_t mapping is the identity mapping.
>> If you changed it, what advantages are there to your approach?

We just used integers for the tids and pids because it was easy, but
they still have an identity mapping.

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

It was pretty difficult and took quite a bit of time. We wouldn't have
gotten this far without the deadline extensions.

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

Yes, it was super helpful for seeing how system calls work. They no
longer feel like a black box that does whatever they need to.

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

For preventing reads/writes to kernel addresses from a user process,
we know what to do and why we want to do it but had no idea where
in the code we needed to implement this feature. Some direction
with this task would have been helpful.

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?
